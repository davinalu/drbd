<?xml version="1.0"?>
<refentry id="re-drbdconf">
  


  <refentryinfo>
    <date>3 December 2012</date>

    <productname class="trade">DRBD</productname>

    <productnumber>9.0.0</productnumber>
  </refentryinfo>

  <refmeta>
    <refentrytitle>drbd.conf</refentrytitle>

    <manvolnum>5</manvolnum>

    <refmiscinfo class="manual">Configuration Files</refmiscinfo>
  </refmeta>

  <refnamediv>
    <refname>drbd.conf</refname>

    <refpurpose>DRBD Configuration Files<indexterm significance="normal">
        <primary>drbd.conf</primary>
      </indexterm></refpurpose>
  </refnamediv>

  <refsect1>
    <title>Introduction</title>

    <para>DRBD implements block devices which replicate their data to all nodes
    of a cluster.  The actual data and associated metadata are usually stored
    redundantly on "ordinary" block devices on each cluster node.</para>

    <para>Replicated block devices are called
    <option>/dev/drbd<replaceable>minor</replaceable></option> by default. They
    are grouped into resources, with one or more devices per resource.
    Replication among the devices in a resource takes place in chronological order. With DRBD,
    we refer to the devices inside a resource as <emphasis>volumes</emphasis>.</para>

    <para>In DRBD 9, a resource can be replicated between two or more cluster
    nodes.  The connections between cluster nodes are point-to-point links, and
    use TCP or a TCP-like protocol.  All nodes must be directly
    connected.</para>

    <para>DRBD consists of low-level user-space components
    which interact with the kernel and perform basic operations
    (<option>drbdsetup</option>, <option>drbdmeta</option>), a high-level
    user-space component which understands and processes the DRBD configuration
    and translates it into basic operations of the low-level components
    (<option>drbdadm</option>), and a kernel component.</para>

    <para>The default DRBD configuration consists of
    <option>/etc/drbd.conf</option> and of additional files included from
    there, usually <option>global_common.conf</option> and all
    <option><replaceable>*</replaceable>.res</option> files inside
    <option>/etc/drbd.d/</option>.  It has turned out to be useful to define
    each resource in a separate
    <option><replaceable>*</replaceable>.res</option> file.</para>

    <para>The configuration files are designed so that each cluster node can
    contain an identical copy of the entire cluster configuration. The host
    name of each node determines which parts of the configuration apply
    (<option>uname -n</option>).
    It is highly recommended to keep the cluster configuration on all
    nodes in sync by manually copying it to all nodes, or by automating the
    process with <option>csync2</option> or a similar tool.</para>
  </refsect1>

  <refsect1>
    <title>Example Configuration File</title>
    <para>
      <programlisting format="linespecific">resource r0 {
      net {
	      cram-hmac-alg sha1;
	      shared-secret "FooFunFactory";
      }
      volume 0 {
	      device    /dev/drbd1;
	      disk      /dev/sda7;
	      meta-disk internal;
      }
      on alice {
	      node-id   0;
	      address   10.1.1.31:7000;
      }
      on bob {
	      node-id   1;
	      address   10.1.1.32:7000;
      }
      connection {
	      host      alice  port 7000;
	      host      bob    port 7000;
	      net {
			protocol C;
	      }
      }
}</programlisting>
    This example defines a resource <option>r0</option> which contains a single replicated
    device with volume number 0.  The resource is replicated among hosts <option>alice</option>
    and <option>bob</option>, which have the IPv4 addresses <option>10.1.1.31</option> and <option>10.1.1.32</option> and the
    node identifiers 0 and 1, respectively.  On both hosts, the replicated
    device is called <option>/dev/drbd1</option>, and the actual data and metadata are stored on
    the lower-level device <option>/dev/sda7</option>.  The connection between the hosts uses
    protocol C.</para>

    <para>Please refer to the <ulink url="http://www.drbd.org/users-guide/"><citetitle>DRBD User's Guide</citetitle></ulink>
      for more examples.</para>

  </refsect1>

  <refsect1>
    <title>File Format</title>

    <para>DRBD configuration files consist of sections, which contain other
    sections and parameters depending on the section types. Each section
    consists of one or more keywords, sometimes a section name, an opening
    brace (<quote>{</quote>), the section's contents, and a closing brace
    (<quote>}</quote>). Parameters inside a section consist of a keyword,
    followed by one or more keywords or values, and a semicolon
    (<quote>;</quote>).</para>

    <para>Some parameter values have a default scale which applies when a plain
    number is specified (for example Kilo, or 1024 times the numeric value).
    Such default scales can be overridden by using a suffix (for example,
    <option>M</option> for Mega).  The common suffixes <option>K</option> =
    2^10 = 1024, <option>M</option> = 1024 K, and <option>G</option> = 1024 M
    are supported.</para>

    <para>Comments start with a hash sign (<quote>#</quote>) and extend to the
    end of the line. In addition, any section can be prefixed with the keyword
    <option>skip</option>, which causes the section and any sub-sections to be
    ignored.</para>

    <para>Additional files can be included with the <option>include
    <replaceable>file-pattern</replaceable></option> statement (see
    <citerefentry><refentrytitle>glob</refentrytitle><manvolnum>7</manvolnum></citerefentry>
    for the expressions supported in <replaceable>file-pattern</replaceable>).
    Include statements are only allowed outside of sections.</para>

    <para>The following sections are defined (indentation indicates in
    which context):
    <programlisting format="linespecific">
common
   [disk]
   [handlers]
   [net]
   [options]
   [startup]
global
resource
   connection
      path
      net
   connection-mesh
      net
   [disk]
   floating
   handlers
   [net]
   on
      volume
         disk
         [disk]
   options
   stacked-on-top-of
   startup</programlisting>
    Sections in brackets affect other parts of the configuration: inside the
    <option>common</option> section, they apply to all resources. A
    <option>disk</option> section inside a <option>resource</option> or
    <option>on</option> section applies to all volumes of that resource, and a
    <option>net</option> section inside a <option>resource</option> section
    applies to all connections of that resource. This allows to avoid repeating
    identical options for each resource, connection, or volume. Options can
    be overridden in a more specific <option>resource</option>,
    <option>connection</option>, <option>on</option>, or
    <option>volume</option> section.</para>

    <refsect2>
      <title>Sections</title>

      <variablelist>
        <varlistentry>
          <term><option>common</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>common</secondary>
              </indexterm> This section can contain each a
              <option>disk</option>, <option>handlers</option>,
              <option>net</option>, <option>options</option>, and
              <option>startup</option> section. All resources inherit the
              parameters in these sections as their default values.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>connection <replaceable><optional>name</optional></replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>connection</secondary>
              </indexterm> Define a connection between two hosts. This section
              must contain two <option>host</option> parameters or multiple
	      <option>path sections</option>.
              The optional <replaceable>name</replaceable> is
              used to refer to the connection in the system log and in other
              messages. If no name is specified, the peer's host name
              is used instead.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>path</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>path</secondary>
              </indexterm> Define a path between two hosts. This section
              must contain two <option>host</option> parameters.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>connection-mesh</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>connection-mesh</secondary>
              </indexterm> Define a connection mesh between multiple hosts. This section
              must contain a <option>hosts</option> parameter, which has the
	      host names as arguments. This section is a shortcut to define many
	      connections which share the same network options.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>disk</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>disk</secondary>
              </indexterm> Define parameters for a volume. All parameters in
              this section are optional.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>floating <replaceable><optional>address-family</optional></replaceable> <replaceable>addr</replaceable>:<replaceable>port</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>floating</secondary>
              </indexterm> Like the <option>on</option> section, except that
              instead of the host name a network address is used to
              determine if it matches a <option>floating</option>
              section.</para>

	    <para>The <option>node-id</option> parameter in this section is
	      required.  If the <option>address</option> parameter is not
	      provided, no connections to peers will be created by default.
	      The <option>device</option>, <option>disk</option>, and
	      <option>meta-disk</option> parameters must be defined in, or
	      inherited by, this section.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>global</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>global</secondary>
              </indexterm> Define some global parameters.  All parameters in
              this section are optional.  Only one <option>global</option>
              section is allowed in the configuration.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>handlers</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>handlers</secondary>
              </indexterm> Define handlers to be invoked when certain events
              occur. The kernel passes the resource name in the first
              command-line argument and sets the following environment
              variables depending on the event's context:
              <itemizedlist>
                <listitem>
                        <para>For events related to a particular device:
                        the device's minor number in
                        <option>DRBD_MINOR</option>, the device's volume number
                        in <option>DRBD_VOLUME</option>.
                  </para>
                </listitem>
                <listitem>
                  <para>For events related to a particular device on a
                  particular peer: the connection endpoints in
                  <option>DRBD_MY_ADDRESS</option>,
                  <option>DRBD_MY_AF</option>,
                  <option>DRBD_PEER_ADDRESS</option>, and
                  <option>DRBD_PEER_AF</option>; the device's local minor
                  number in <option>DRBD_MINOR</option>, and the device's volume
                  number in <option>DRBD_VOLUME</option>.
                  </para>
                </listitem>
                <listitem>
                  <para>For events related to a particular connection: the
                  connection endpoints in <option>DRBD_MY_ADDRESS</option>,
                  <option>DRBD_MY_AF</option>,
                  <option>DRBD_PEER_ADDRESS</option>, and
                  <option>DRBD_PEER_AF</option>; and, for each device defined for
                  that connection: the device's minor number in
                  <option>DRBD_MINOR_<replaceable>volume-number</replaceable></option>.
                  </para>
                </listitem>
                <listitem>
                  <para>For events that identify a device, if a lower-level
                  device is attached, the lower-level device's device name is
                  passed in <option>DRBD_BACKING_DEV</option> (or
                  <option>DRBD_BACKING_DEV_<replaceable>volume-number</replaceable></option>).
                  </para>
              </listitem>
              </itemizedlist>
            </para>
            <para>All parameters in this section are optional. Only a single
            handler can be defined for each event; if no handler is defined,
            nothing will happen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><anchor xml:id="net"/><option>net</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>net</secondary>
              </indexterm> Define parameters for a connection. All parameters
              in this section are optional.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>on</option> <option><replaceable>host-name</replaceable></option> <replaceable><optional>...</optional></replaceable></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>on</secondary>
              </indexterm> Define the properties of a resource on a particular
              host or set of hosts. Specifying more than one host name can
              make sense in a setup with IP address failover, for
              example. The <replaceable>host-name</replaceable> argument must
              match the Linux host name (<option>uname -n</option>).</para>

            <para>Usually contains or inherits at least one
            <option>volume</option> section. The <option>node-id</option> and
            <option>address</option> parameters must be defined in this
            section. The <option>device</option>, <option>disk</option>, and
            <option>meta-disk</option> parameters must be defined in, or
            inherited by, this section.</para>

            <para>A normal configuration file contains two or more
            <option>on</option> sections for each resource. Also see the
            <option>floating</option> section.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>options</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>options</secondary>
              </indexterm> Define parameters for a resource. All parameters
              in this section are optional.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>resource</option> <option><replaceable>name</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>resource</secondary>
              </indexterm> Define a resource. Usually contains at least two
              <option>on</option> sections and at least one
              <option>connection</option> section. <!-- FIXME? auto-mesh? --></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>stacked-on-top-of <replaceable>resource</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>stacked-on-top-of</secondary>
            </indexterm> Used instead of an <option>on</option> section for
            configuring a stacked resource with three to four nodes.</para>
	  <para>Starting with DRBD 9, stacking is deprecated.  It is advised
	    to use resources which are replicated among more than two nodes
	    instead.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>startup</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>startup</secondary>
              </indexterm> The parameters in this section determine the
              behavior of a resource at startup time.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>volume</option> <option><replaceable>volume-number</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>volume</secondary>
              </indexterm> Define a volume within a resource. The volume
              numbers in the various <option>volume</option> sections of a
              resource define which devices on which hosts form a replicated
              device.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>connection</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>host <replaceable>name</replaceable></option>
            <optional><option>address
                <optional>address-family</optional>
                <replaceable>address</replaceable></option></optional>
            <optional><option>port
                <replaceable>port-number</replaceable></option></optional></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>host</secondary>
              </indexterm>
            Defines an endpoint for a connection. Each <option>host</option>
            statement refers to an <option>on</option> section in a resource.
            If a port number is defined, this endpoint will use the specified
            port instead of the port defined in the <option>on</option>
            section.  Each <option>connection</option> section must contain
            exactly two <option>host</option> parameters. Instead of two
	    <option>host</option> parameters the connection may contain
	    multiple <option>path</option> sections.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>path</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>host <replaceable>name</replaceable></option>
            <optional><option>address
                <optional>address-family</optional>
                <replaceable>address</replaceable></option></optional>
            <optional><option>port
                <replaceable>port-number</replaceable></option></optional></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>host</secondary>
              </indexterm>
            Defines an endpoint for a connection. Each <option>host</option>
            statement refers to an <option>on</option> section in a resource.
            If a port number is defined, this endpoint will use the specified
            port instead of the port defined in the <option>on</option>
            section.  Each <option>path</option> section must contain
            exactly two <option>host</option> parameters.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>connection-mesh</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>hosts <arg choice="plain" rep="repeat"><replaceable>name</replaceable></arg></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>host</secondary>
              </indexterm>
            Defines all nodes of a mesh. Each
	    <option><replaceable>name</replaceable></option> refers to an
	    <option>on</option> section in a resource. The port
	    that is defined in the <option>on</option> section will
	    be used.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>disk</option> Parameters</title>

      <variablelist>
	<varlistentry><term xml:id="al-extents"><option>al-extents <replaceable>extents</replaceable></option>
    </term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>al-extents</secondary>
	</indexterm> DRBD automatically maintains a "hot" or "active" disk area
      likely to be written to again soon based on the recent write activity.
      The "active" disk area can be written to immediately, while "inactive"
      disk areas must be "activated" first, which requires a meta-data write.
      We also refer to this active disk area as the "activity log".</para><para>The activity log saves meta-data writes, but the whole log must be
      resynced upon recovery of a failed node.  The size of the activity log is
      a major factor of how long a resync will take and how fast a replicated
      disk will become consistent after a crash.</para><para>The activity log consists of a number of 4-Megabyte segments; the
      <replaceable>al-extents</replaceable> parameter determines how many of
      those segments can be active at the same time.  The default value for
      <replaceable>al-extents</replaceable> is 1237, with a minimum of 7 and a
      maximum of 65536.</para><para>
	Note that the effective maximum may be smaller, depending on how
	you created the device meta data, see also
	<citerefentry><refentrytitle>drbdmeta</refentrytitle><manvolnum>8</manvolnum></citerefentry>
	The effective maximum is 919 * (available on-disk activity-log ring-buffer area/4kB -1),
	the default 32kB ring-buffer effects a maximum of 6433 (covers more than 25 GiB of data)
	We recommend to keep this well within the amount your backend storage
	and replication link are able to resync inside of about 5 minutes.
      </para></listitem></varlistentry>
	<varlistentry><term xml:id="al-updates"><option>al-updates
	<group choice="req" rep="norepeat">
	  <arg choice="plain" rep="norepeat">yes</arg>
	  <arg choice="plain" rep="norepeat">no</arg>
        </group>
      </option>
    </term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>
	  <secondary>al-updates</secondary>
	</indexterm> With this parameter, the activity log can be turned off
      entirely (see the <option>al-extents</option> parameter). This will speed
      up writes because fewer meta-data writes will be necessary, but the
      entire device needs to be resynchronized opon recovery of a failed
      primary node.  The default value for <option>al-updates</option> is
      <option>yes</option>.
      </para></listitem></varlistentry>
	<varlistentry><term xml:id="c-delay-target"><option>c-delay-target <replaceable>delay_target</replaceable></option></term><term xml:id="c-fill-target"><option>c-fill-target <replaceable>fill_target</replaceable></option></term><term xml:id="c-max-rate"><option>c-max-rate <replaceable>max_rate</replaceable></option></term><term xml:id="c-plan-ahead"><option>c-plan-ahead <replaceable>plan_time</replaceable></option></term><listitem><para>Dynamically control the resync speed.  This mechanism is enabled by
      setting the <option>c-plan-ahead</option> parameter to a positive value.
      The goal is to either fill the buffers along the data path with a defined
      amount of data if <option>c-fill-target</option> is defined, or to have a
      defined delay along the path if <option>c-delay-target</option> is
      defined. The maximum bandwidth is limited by the
      <option>c-max-rate</option> parameter.</para><para>The <option>c-plan-ahead</option> parameter defines how fast drbd
      adapts to changes in the resync speed.  It should be set to five times
      the network round-trip time or more.  Common values for
      <option>c-fill-target</option> for "normal" data paths range from 4K to
      100K. If drbd-proxy is used, it is advised to use
      <option>c-delay-target</option> instead of <option>c-fill-target</option>. The
      <option>c-delay-target</option> parameter is used if the
      <option>c-fill-target</option> parameter is undefined or set to 0.  The
      <option>c-delay-target</option> parameter should be set to five times the
      network round-trip time or more. The <option>c-max-rate</option> option
      should be set to either the bandwidth available between the DRBD-hosts and the
      machines hosting DRBD-proxy, or to the available disk bandwidth.</para><para>The default values of these parameters are:
      <option>c-plan-ahead</option> = 20 (in units of 0.1 seconds),
      <option>c-fill-target</option> = 0 (in units of sectors),
      <option>c-delay-target</option> = 1 (in units of 0.1 seconds),
      and <option>c-max-rate</option> = 102400 (in units of KiB/s).</para><para>Dynamic resync speed control is available since DRBD 8.3.9.</para></listitem></varlistentry>
	<varlistentry><term xml:id="c-min-rate"><option>c-min-rate <replaceable>min_rate</replaceable></option></term><listitem><para>A node which is primary and sync-source has to schedule application
      I/O requests and resync I/O requests. The <option>c-min-rate</option>
      parameter limits how much bandwidth is available for resync I/O; the
      remaining bandwidth is used for application I/O.</para><para>A <option>c-min-rate</option> value of 0 means that there is no
      limit on the resync I/O bandwidth. This can slow down application I/O
      significantly. Use a value of 1 (1 KiB/s) for the lowest possible resync
      rate.</para><para>The default value of <option>c-min-rate</option> is 4096, in units of
      KiB/s.</para></listitem></varlistentry>
	<varlistentry><term xml:id="disk-barrier"><option>disk-barrier</option></term><term xml:id="disk-flushes"><option>disk-flushes</option></term><term xml:id="disk-drain"><option>disk-drain</option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>
	<secondary>disk-barrier</secondary>
      </indexterm><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>disk-flushes</secondary>
      </indexterm><indexterm significance="normal">
	<primary>drbd.conf</primary>
	<secondary>disk-drain</secondary>
      </indexterm><para>DRBD has three methods of handling the ordering of dependent write
      requests:
	<variablelist>
	  <varlistentry>
	    <term><option>disk-barrier</option></term>
	    <listitem>
	      <para>Use disk barriers to make sure that requests are written to
	      disk in the right order. Barriers ensure that all requests
	      submitted before a barrier make it to the disk before any
	      requests submitted after the barrier.  This is implemented using
	      'tagged command queuing' on SCSI devices and 'native command
	      queuing' on SATA devices. Only some devices and device stacks
	      support this method. The device mapper (LVM) only supports
	      barriers in some configurations.</para>

	      <para>Note that on systems which do not support
	      disk barriers, enabling this option can lead to data loss or
	      corruption. Until DRBD 8.4.1, <option>disk-barrier</option> was
	      turned on if the I/O stack below DRBD did support barriers.
	      Kernels since linux-2.6.36 (or 2.6.32 RHEL6) no longer allow to
	      detect if barriers are supported. Since drbd-8.4.2,
	      this option is off by default and needs to be enabled explicitly.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><option>disk-flushes</option></term>
	    <listitem>
	      <para>Use disk flushes between dependent write requests, also
	      referred to as 'force unit access' by drive vendors. This forces
	      all data to disk. This option is enabled by default.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><option>disk-drain</option></term>
	    <listitem>
	      <para>Wait for the request queue to "drain" (that is, wait for
	      the requests to finish) before submitting a dependent write
	      request. This method requires that requests are stable on disk
	      when they finish. Before DRBD 8.0.9, this was the only method
	      implemented. This option is enabled by default. Do not disable
	      in production environments.
	    </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	From these three methods, drbd will use the first that is enabled and
	supported by the backing storage device.  If all three of these options
	are turned off, DRBD will submit write requests without bothering about
	dependencies. Depending on the I/O stack, write requests can be
	reordered, and they can be submitted in a different order on different
	cluster nodes. This can result in data loss or corruption. Therefore,
	turning off all three methods of controlling write ordering is strongly
	discouraged.
      </para><para>A general guideline for configuring write ordering is to use disk
      barriers or disk flushes when using ordinary disks (or an ordinary disk
      array) with a volatile write cache. On storage without cache or with a
      battery backed write cache, disk draining can be a reasonable
      choice.</para></listitem></varlistentry>
	<varlistentry><term xml:id="disk-timeout"> <option>disk-timeout</option>
    </term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>
	<secondary>disk-timeout</secondary>
      </indexterm><para>If the lower-level device on which a DRBD device stores its data does
      not finish an I/O request within the defined
      <option>disk-timeout</option>, DRBD treats this as a failure. The
      lower-level device is detached, and the device's disk state advances to
      Diskless.  If DRBD is connected to one or more peers, the failed request
      is passed on to one of them.</para><para>This option is <emphasis>dangerous and may lead to kernel panic!</emphasis></para><para>"Aborting" requests, or force-detaching the disk, is intended for
      completely blocked/hung local backing devices which do no longer
      complete requests at all, not even do error completions.  In this
      situation, usually a hard-reset and failover is the only way out.</para><para>By "aborting", basically faking a local error-completion,
      we allow for a more graceful swichover by cleanly migrating services.
      Still the affected node has to be rebooted "soon".</para><para>By completing these requests, we allow the upper layers to re-use
      the associated data pages.</para><para>If later the local backing device "recovers", and now DMAs some data
      from disk into the original request pages, in the best case it will
      just put random data into unused pages; but typically it will corrupt
      meanwhile completely unrelated data, causing all sorts of damage.</para><para>Which means delayed successful completion,
      especially for READ requests, is a reason to panic().
      We assume that a delayed *error* completion is OK,
      though we still will complain noisily about it.</para><para>The default value of
      <option>disk-timeout</option> is 0, which stands for an infinite timeout.
      Timeouts are specified in units of 0.1 seconds. This option is available
      since DRBD 8.3.12.</para></listitem></varlistentry>
	<varlistentry><term xml:id="fencing"><option>fencing <replaceable>fencing_policy</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>fencing</secondary>
	</indexterm> <option>Fencing</option> is a preventive measure to avoid
      situations where both nodes are primary and disconnected. This is also
      known as a split-brain situation. DRBD supports the following fencing
      policies:</para><variablelist>
	<varlistentry>
	  <term xml:id="dont-care"><option>dont-care</option></term>

	  <listitem>
	    <para>No fencing actions are taken. This is the default policy.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="resource-only"><option>resource-only</option></term>

	  <listitem>
	    <para>If a node becomes a disconnected primary, it tries to fence the peer.
	    This is done by calling the <option>fence-peer</option> handler. The
	    handler is supposed to reach the peer over an alternative communication path
	    and call '<option>drbdadm outdate minor</option>' there.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="resource-and-stonith"><option>resource-and-stonith</option></term>

	  <listitem>
	    <para>If a node becomes a disconnected primary, it freezes all its IO operations
	    and calls its fence-peer handler. The fence-peer handler is supposed to reach
	    the peer over an alternative communication path and call
	    '<option>drbdadm outdate minor</option>' there. In case it cannot
	    do that, it should stonith the peer. IO is resumed as soon as
	    the situation is resolved. In case the fence-peer  handler fails,
	    I/O can be resumed manually with '<option>drbdadm
	    resume-io</option>'.</para>
	  </listitem>
	</varlistentry>
      </variablelist></listitem></varlistentry>
	<varlistentry><term xml:id="md-flushes"><option>md-flushes</option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>md-flushes</secondary>
      </indexterm><para>Enable disk flushes and disk barriers on the meta-data device.
      This option is enabled by default.  See the <option>disk-flushes</option>
      parameter.</para></listitem></varlistentry>
	<varlistentry><term xml:id="on-io-error"><option>on-io-error <replaceable>handler</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>on-io-error</secondary>
	</indexterm> Configure how DRBD reacts to I/O errors on a
	lower-level device. The following policies are defined:

	<variablelist>
	  <varlistentry>
	    <term xml:id="pass_on"><option>pass_on</option></term>
	    <listitem>
	      <para>Change the disk status to Inconsistent, mark the failed
	      block as inconsistent in the bitmap, and retry the I/O operation
	      on a remote cluster node.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term xml:id="call-local-io-error"><option>call-local-io-error</option></term>
	    <listitem>
	      <para>Call the <option>local-io-error</option> handler (see the
	      <option>handlers</option> section).</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term xml:id="detach"><option>detach</option></term>
	    <listitem>
	      <para>Detach the lower-level device and continue in diskless mode.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para></listitem></varlistentry>
	<varlistentry><term xml:id="read-balancing"><option>read-balancing <replaceable>policy</replaceable></option>
    </term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>
	<secondary>read-balancing</secondary>
      </indexterm><para>
	Distribute read requests among cluster nodes as defined by
	<replaceable>policy</replaceable>. The supported policies are
	<option xml:id="prefer-local">prefer-local</option> (the default),
	<option xml:id="prefer-remote">prefer-remote</option>, <option xml:id="round-robin">round-robin</option>,
	<option xml:id="least-pending">least-pending</option>, <option xml:id="when-congested-remote">when-congested-remote</option>,
	<option xml:id="_32K-striping">32K-striping</option>, <option xml:id="_64K-striping">64K-striping</option>,
	<option xml:id="_128K-striping">128K-striping</option>, <option xml:id="_256K-striping">256K-striping</option>,
	<option xml:id="_512K-striping">512K-striping</option> and <option xml:id="_1M-striping">1M-striping</option>.</para><para>This option is available since DRBD 8.4.1.</para></listitem></varlistentry>
	<varlistentry><term xml:id="resync-after">
	
	
	  <option>resync-after <replaceable>res-name</replaceable>/<replaceable>volume</replaceable></option>
	
      </term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>resync-after</secondary>
	</indexterm> Define that a device should only resynchronize after the
	specified other device. By default, no order between devices is
	defined, and all devices will resynchronize in parallel. Depending on
	the configuration of the lower-level devices, and the available
	network and disk bandwidth, this can slow down the overall resync
	process.  This option can be used to form a chain or tree of
	dependencies among devices.</para></listitem></varlistentry>
	<varlistentry><term xml:id="resync-rate"><option>resync-rate <replaceable>rate</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>resync-rate</secondary>
	</indexterm> Define how much bandwidth DRBD may use for
	resynchronizing.  DRBD allows "normal" application I/O even during a
	resync. If the resync takes up too much bandwidth, application I/O
	can become very slow. This parameter allows to avoid that. Please
	note this is option only works when the dynamic resync controller is
	disabled.</para></listitem></varlistentry>
	<varlistentry><term>
      <option>rs-discard-granularity <replaceable>byte</replaceable></option>
    </term><listitem><indexterm significance="normal">
        <primary>drbd.conf</primary>
        <secondary>rs-discard-granularity</secondary>
      </indexterm><para>
        When <option>rs-discard-granularity</option> is set to a non zero, positive
        value then DRBD tries to do a resync operation in requests of this size.
        In case such a block contains only zero bytes on the sync source node,
        the sync target node will issue a discard/trim/unmap command for
        the area.</para><para>The value is constrained by the discard granularity of the backing
	block device. In case <option>rs-discard-granularity</option> is not a
	multiplier of the discard granularity of the backing block device DRBD
	rounds it up. The feature only gets active if the backing block device
	reads back zeroes after a discard command.</para><para> The default value of is 0. This option is available since 8.4.7.
        </para></listitem></varlistentry>
	<varlistentry><term xml:id="discard-zeroes-if-aligned"><option>discard-zeroes-if-aligned <group choice="req" rep="norepeat">
    <arg choice="plain" rep="norepeat">yes</arg>
    <arg choice="plain" rep="norepeat">no</arg>
    </group></option></term><listitem><para>
        <indexterm significance="normal">
          <primary>drbd.conf</primary>
          <secondary>discard-zeroes-if-aligned</secondary>
        </indexterm>
	There are several aspects to discard/trim/unmap support on linux
	block devices.  Even if discard is supported in general, it may fail
	silently, or may partially ignore discard requests.  Devices also
	announce whether reading from unmapped blocks returns defined data
	(usually zeroes), or undefined data (possibly old data, possibly
	garbage).
	</para><para>
	If on different nodes, DRBD is backed by devices with differing discard
	characteristics, discards may lead to data divergence (old data or
	garbage left over on one backend, zeroes due to unmapped areas on the
	other backend). Online verify would now potentially report tons of
	spurious differences.  While probably harmless for most use cases
	(fstrim on a file system), DRBD cannot have that.
	</para><para>
	To play safe, we have to disable discard support, if our local backend
	(on a Primary) does not support "discard_zeroes_data=true".  We also have to
	translate discards to explicit zero-out on the receiving side, unless
	the receiving side (Secondary) supports "discard_zeroes_data=true",
	thereby allocating areas what were supposed to be unmapped.
	</para><para>
	There are some devices (notably the LVM/DM thin provisioning) that are
	capable of discard, but announce discard_zeroes_data=false.  In the case of
	DM-thin, discards aligned to the chunk size will be unmapped, and
	reading from unmapped sectors will return zeroes. However, unaligned
	partial head or tail areas of discard requests will be silently ignored.
	</para><para>
	If we now add a helper to explicitly zero-out these unaligned partial
	areas, while passing on the discard of the aligned full chunks, we
	effectively achieve discard_zeroes_data=true on such devices.
	</para><para>
	Setting <option>discard-zeroes-if-aligned</option> to <option>yes</option>
	will allow DRBD to use discards, and to announce discard_zeroes_data=true,
	even on backends that announce discard_zeroes_data=false.
	</para><para>
	Setting <option>discard-zeroes-if-aligned</option> to <option>no</option>
	will cause DRBD to always fall-back to zero-out on the receiving side,
	and to not even announce discard capabilities on the Primary,
	if the respective backend announces discard_zeroes_data=false.
	</para><para>
	We used to ignore the discard_zeroes_data setting completely.  To not
	break established and expected behaviour, and suddenly cause fstrim on
	thin-provisioned LVs to run out-of-space instead of freeing up space,
	the default value is <option>yes</option>.
	</para><para>
	This option is available since 8.4.7.
      </para></listitem></varlistentry>

	<!-- <pick_drbdsetup_option name="size"/> -->
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>global</option> Parameters</title>

      <variablelist>
        <varlistentry><term xml:id="dialog-refresh"><option>dialog-refresh <replaceable>time</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>dialog-refresh</secondary>
	</indexterm> The DRBD init script can be used to configure and start
	DRBD devices, which can involve waiting for other cluster nodes.
	While waiting, the init script shows the remaining waiting time.  The
	<option>dialog-refresh</option> defines the number of seconds between
	updates of that countdown. The default value is 1; a value of 0 turns
	off the countdown.</para></listitem></varlistentry>
        <varlistentry><term xml:id="disable-ip-verification"><option>disable-ip-verification</option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>disable-ip-verification</secondary>
      </indexterm><para>
	Normally, DRBD verifies that the IP addresses in the configuration
	match the host names. Use the <option>disable-ip-verification</option>
	parameter to disable these checks.
      </para></listitem></varlistentry>
        <varlistentry><term xml:id="usage-count"><option>usage-count
	<group choice="req" rep="norepeat">
	  <arg choice="plain" rep="norepeat">yes</arg>
	  <arg choice="plain" rep="norepeat">no</arg>
	  <arg choice="plain" rep="norepeat">ask</arg>
        </group>
    </option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>usage-count</secondary>
      </indexterm><para>A explained on DRBD's <ulink url="http://usage.drbd.org"><citetitle>
      Online Usage Counter</citetitle></ulink> web page, DRBD includes a
      mechanism for anonymously counting how many installations are using which
      versions of DRBD. The results are available on the web page for anyone to
      see.</para><para>This parameter defines if a cluster node participates in the usage
      counter; the supported values are <option>yes</option>,
      <option>no</option>, and <option>ask</option> (ask the user, the
      default).</para><para>We would like to ask users to participate in the online usage
      counter as this provides us valuable feedback for steering the
      development of DRBD.</para></listitem></varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>handlers</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>after-resync-target <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>after-resync-target</secondary>
              </indexterm> Called on a resync target when a node state
              changes from <option>Inconsistent</option> to <option>Consistent</option> when a resync finishes.
              This handler can be used for removing the snapshot created in the
              <option>before-resync-target</option> handler.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>before-resync-target <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>before-resync-target</secondary>
              </indexterm> Called on a resync target before a resync begins.
              This handler can be used for creating a snapshot of the
              lower-level device for the duration of the resync: if the resync
              source becomes unavailable during a resync, reverting to the
              snapshot can restore a consistent state.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>fence-peer <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>fence-peer</secondary>
              </indexterm> Called when a node should fence a resource on a
              particular peer. The handler should not use the same
              communication path that DRBD uses for talking to the peer.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>unfence-peer <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>unfence-peer</secondary>
              </indexterm> Called when a node should remove fencing constraints
	      from other nodes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>initial-split-brain <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>initial-split-brain</secondary>
              </indexterm> Called when DRBD connects to a peer and detects that
              the peer is in a split-brain state with the local node.  This
              handler is also called for split-brain scenarios which will be
              resolved automatically.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>local-io-error <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>local-io-error</secondary>
              </indexterm> Called when an I/O error occurs on a lower-level device.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>pri-lost <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>pri-lost</secondary>
              </indexterm>
              The local node is currently primary, but DRBD believes that it
              should become a sync target. The node should give up its primary
              role.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>pri-lost-after-sb <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>pri-lost-after-sb</secondary>
              </indexterm> The local node is currently primary, but it has lost
              the after-split-brain auto recovery procedure. The node should be
              abandoned. <!-- FIXME: What is "abandon a node" supposed to mean? --></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>pri-on-incon-degr <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>pri-on-incon-degr</secondary>
	      </indexterm> The local node is primary, and neither the local
	    lower-level device nor a lower-level device on a peer is up to
	    date.  (The primary has no device to read from or to write
	    to.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>split-brain <replaceable>cmd</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>split-brain</secondary>
              </indexterm> DRBD has detected a split-brain situation which
              could not be resolved automatically.  Manual recovery is
              necessary. This handler can be used to call for administrator
              attention.</para>
          </listitem>
        </varlistentry>

      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>net</option> Parameters</title>

      <variablelist>
        <varlistentry><term xml:id="after-sb-0pri"><option>after-sb-0pri <replaceable>policy</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>after-sb-0pri</secondary>
      </indexterm><para>Define how to react if a split-brain scenario is detected and none
      of the two nodes is in primary role.  (We detect split-brain scenarios
      when two nodes connect; split-brain decisions are always between two
      nodes.) The defined policies are:</para><variablelist>
	<varlistentry>
	  <term><option>disconnect</option></term>

	  <listitem>
	    <para>No automatic resynchronization; simply disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>discard-younger-primary</option></term>
	  <term><option>discard-older-primary</option></term>

	  <listitem>
	    <para>Resynchronize from the node which became primary first
	      (<option>discard-younger-primary</option>) or last
	      (<option>discard-older-primary</option>).  If both nodes became
	      primary independently, the <option>discard-least-changes</option>
	      policy is used.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>discard-zero-changes</option></term>

	  <listitem>
	    <para>If only one of the nodes wrote data since the split brain
	    situation was detected, resynchronize from this node to the other.
	    If both nodes wrote data, disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>discard-least-changes</option></term>

	  <listitem>
	    <para>Resynchronize from the node with more modified blocks.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>discard-node-<replaceable>nodename</replaceable></option></term>

	  <listitem>
	    <para>Always resynchronize to the named node.</para>
	  </listitem>
	</varlistentry>
      </variablelist></listitem></varlistentry>
        <varlistentry><term xml:id="after-sb-1pri"><option>after-sb-1pri <replaceable>policy</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>after-sb-1pri</secondary>
      </indexterm><para>Define how to react if a split-brain scenario is detected, with one
      node in primary role and one node in secondary role.  (We detect
      split-brain scenarios when two nodes connect, so split-brain decisions
      are always among two nodes.)  The defined policies are:</para><variablelist>
	<varlistentry>
	  <term><option>disconnect</option></term>

	  <listitem>
	    <para>No automatic resynchronization, simply disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>consensus</option></term>

	  <listitem>
	    <para>Discard the data on the secondary node if the
	    <option>after-sb-0pri</option> algorithm would also discard the
	    data on the secondary node.  Otherwise, disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>violently-as0p</option></term>

	  <listitem>
	    <para>Always take the decision of the <option>after-sb-0pri</option> algorithm,
	      even if it causes an erratic change of the primary's view of the
	      data. This is only useful if a single-node file system (i.e., not
	      OCFS2 or GFS) with the <option>allow-two-primaries</option> flag
	      is used.  This option can cause the primary node to crash, and
	      should not be used.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="discard-secondary"><option>discard-secondary</option></term>

	  <listitem>
	    <para>Discard the data on the secondary node.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="call-pri-lost-after-sb"><option>call-pri-lost-after-sb</option></term>

	  <listitem>
	    <para>Always take the decision of the
	    <option>after-sb-0pri</option> algorithm.  If the decision is to
	    discard the data on the primary node, call the
	    <option xml:id="pri-lost-after-sb">pri-lost-after-sb</option> handler on the primary
	    node.</para>
	  </listitem>
	</varlistentry>
      </variablelist></listitem></varlistentry>
        <varlistentry><term xml:id="after-sb-2pri"><option>after-sb-2pri <replaceable>policy</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>after-sb-2pri</secondary>
      </indexterm><para>Define how to react if a split-brain scenario is detected and both
      nodes are in primary role.  (We detect split-brain scenarios when two
      nodes connect, so split-brain decisions are always among two nodes.)  The
      defined policies are:</para><variablelist>
	<varlistentry>
	  <term><option>disconnect</option></term>

	  <listitem>
	    <para>No automatic resynchronization, simply disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="violently-as0p"><option>violently-as0p</option></term>

	  <listitem>
	    <para>See the <option>violently-as0p</option> policy for
	      <option>after-sb-1pri</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>call-pri-lost-after-sb</option></term>

    <listitem>
      <para>Call the <option>pri-lost-after-sb</option> helper program on one
        of the machines unless that machine can demote to secondary. The helper
        program is expected to reboot the machine, which brings the node into
        a secondary role. Which machine runs the helper program is determined
        by the <option>after-sb-0pri</option> strategy.</para>
    </listitem>
  </varlistentry>
      </variablelist></listitem></varlistentry>
        <varlistentry><term xml:id="allow-two-primaries"><option>allow-two-primaries</option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>allow-two-primaries</secondary>
	</indexterm> The most common way to configure DRBD devices is to allow
	only one node to be primary (and thus writable) at a time.</para><para>In some scenarios it is preferable to allow two nodes to be
	primary at once; a mechanism outside of DRBD then must make sure that
	writes to the shared, replicated device happen in a coordinated way.
	This can be done with a shared-storage cluster file system like OCFS2
	and GFS, or with virtual machine images and a virtual machine manager
	that can migrate virtual machines between physical machines.</para><para>The <option>allow-two-primaries</option> parameter tells DRBD to
	allow two nodes to be primary at the same time. Never enable this
	option when using a non-distributed file system; otherwise, data
	corruption and node crashes will result!</para></listitem></varlistentry>
        <varlistentry><term xml:id="always-asbp"><option>always-asbp</option></term><listitem><para>Normally the automatic after-split-brain policies are only used if current
      states of the UUIDs do not indicate the presence of a third node.</para><para>With this option you request that the automatic after-split-brain policies are
      used as long as the data sets of the nodes are somehow related. This might cause a
      full sync, if the UUIDs indicate the presence of a third node. (Or double faults led
      to strange UUID sets.)</para></listitem></varlistentry>
        <varlistentry><term xml:id="connect-int"><option>connect-int <replaceable>time</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>connect-int</secondary>
	</indexterm> As soon as a connection between two nodes is configured
	with <command moreinfo="none">drbdsetup connect</command>, DRBD
	immediately tries to establish the connection. If this fails, DRBD
	waits for <option>connect-int</option> seconds and then repeats.  The
	default value of <option>connect-int</option> is 10 seconds.</para></listitem></varlistentry>
        <varlistentry><term xml:id="cram-hmac-alg"><option>cram-hmac-alg <replaceable>hash-algorithm</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>cram-hmac-alg</secondary>
	</indexterm> Configure the hash-based message authentication code
	(HMAC) or secure hash algorithm to use for peer authentication. The
	kernel supports a number of different algorithms, some of which may be
	loadable as kernel modules. See the shash algorithms listed in
	/proc/crypto.  By default, <option>cram-hmac-alg</option> is unset.
	Peer authentication also requires a <option>shared-secret</option> to
	be configured.</para></listitem></varlistentry>
        <varlistentry><term xml:id="csum-alg"><option>csums-alg <replaceable>hash-algorithm</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>csums-alg</secondary>
	</indexterm> Normally, when two nodes resynchronize, the sync target
	requests a piece of out-of-sync data from the sync source, and the sync
	source sends the data.  With many usage patterns, a significant number of those blocks
	will actually be identical.</para><para>When a <option>csums-alg</option> algorithm is specified, when
	requesting a piece of out-of-sync data, the sync target also sends
	along a hash of the data it currently has. The sync source compares
	this hash with its own version of the data.  It sends the sync target
	the new data if the hashes differ, and tells it that the data are the
	same otherwise. This reduces the network bandwidth required, at the
	cost of higher cpu utilization and possibly increased I/O on the sync
	target.</para><para>The <option>csums-alg</option> can be set to one of the secure
	hash algorithms supported by the kernel; see the shash algorithms
	listed in /proc/crypto.  By default, <option>csums-alg</option> is
	unset.</para></listitem></varlistentry>
        <varlistentry><term xml:id="csums-after-crash-only"><option>csums-after-crash-only</option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>csums-after-crash-only</secondary>
	</indexterm> Enabling this option (and csums-alg, above) makes it possible to
        use the checksum based resync only for the first resync after primary crash,
      but not for later "network hickups".</para><para>In most cases, block that are marked as need-to-be-resynced are in fact changed,
      so calculating checksums, and both reading and writing the blocks on the resync target
      is all effective overhead.</para><para>The advantage of checksum based resync is mostly after primary crash recovery,
      where the recovery marked larger areas (those covered by the activity log)
      as need-to-be-resynced, just in case. Introduced in 8.4.5.</para></listitem></varlistentry>
        <varlistentry><term xml:id="data-integrity-alg"><option>data-integrity-alg </option> <replaceable>alg</replaceable></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>data-integrity-alg</secondary>
      </indexterm><para>DRBD normally relies on the data integrity checks built into the
      TCP/IP protocol, but if a data integrity algorithm is configured, it will
      additionally use this algorithm to make sure that the data received over
      the network match what the sender has sent.  If a data integrity error is
      detected, DRBD will close the network connection and reconnect, which
      will trigger a resync.</para><para>The <option>data-integrity-alg</option> can be set to one of the
      secure hash algorithms supported by the kernel; see the shash algorithms
      listed in /proc/crypto. By default, this mechanism is turned off.</para><para>Because of the CPU overhead involved, we recommend not to use this
	option in production environments.  Also see the notes on data
	integrity below.</para></listitem></varlistentry>
        <varlistentry><term xml:id="ko-count"><option>ko-count <replaceable>number</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>ko-count</secondary>
	</indexterm> If a secondary node fails to complete a write request in
      <option>ko-count</option> times the <option>timeout</option> parameter,
      it is excluded from the cluster. The primary node then sets the
      connection to this secondary node to Standalone.
      To disable this feature, you should explicitly set it to 0; defaults may change between versions.
      </para></listitem></varlistentry>
        <varlistentry><term xml:id="max-buffers"><option>max-buffers <replaceable>number</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>max-buffers</secondary>
	</indexterm> Limits the memory usage per DRBD minor device on the receiving side,
	or for internal buffers during resync or online-verify.
	Unit is PAGE_SIZE, which is 4 KiB on most systems.
	The minimum possible setting is hard coded to 32 (=128 KiB).
	These buffers are used to hold data blocks while they are written to/read from disk.
	To avoid possible distributed deadlocks on congestion, this setting is used
	as a throttle threshold rather than a hard limit.  Once more than max-buffers
	pages are in use, further allocation from this pool is throttled.
	You want to increase max-buffers if you cannot saturate the IO backend on the
        receiving side.</para></listitem></varlistentry>
        <varlistentry><term xml:id="max-epoch-size"><option>max-epoch-size <replaceable>number</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>max-epoch-size</secondary>
	</indexterm> Define the maximum number of write requests DRBD may issue
	before issuing a write barrier.  The default value is 2048, with a
	minimum of 1 and a maximum of 20000.  Setting this parameter to a value
	below 10 is likely to decrease performance.</para></listitem></varlistentry>
        <varlistentry><term xml:id="on-congestion"><option>on-congestion <replaceable>policy</replaceable></option></term><term xml:id="congestion-fill"><option>congestion-fill <replaceable>threshold</replaceable></option></term><term xml:id="congestion-extents"><option>congestion-extents
    <replaceable>threshold</replaceable></option></term><listitem><para>By default, DRBD blocks when the TCP send queue is full. This prevents
      applications from generating further write requests until more buffer
      space becomes available again.</para><para>When DRBD is used together with DRBD-proxy, it can be better to use
      the <option>pull-ahead</option> <option>on-congestion</option> policy,
      which can switch DRBD into ahead/behind mode before the send queue is full.
      DRBD then records the differences between itself and the peer in its
      bitmap, but it no longer replicates them to the peer.  When enough buffer
      space becomes available again, the node resynchronizes with the peer and
      switches back to normal replication.</para><para>This has the advantage of not blocking application I/O even when the
      queues fill up, and the disadvantage that peer nodes can fall behind much
      further.  Also, while resynchronizing, peer nodes will become
      inconsistent.</para><para>The available congestion policies are <option>block</option> (the
      default) and <option>pull-ahead</option>.  The
      <option>congestion-fill</option> parameter defines how much data is
      allowed to be "in flight" in this connection.  The default value is 0,
      which disables this mechanism of congestion control, with a maximum of
      10 GiBytes.  The <option>congestion-extents</option> parameter defines
      how many bitmap extents may be active before switching into ahead/behind
      mode, with the same default and limits as the <option>al-extents</option>
      parameter.  The <option>congestion-extents</option> parameter is
      effective only when set to a value smaller than
      <option>al-extents</option>.</para><para>Ahead/behind mode is available since DRBD 8.3.10.</para></listitem></varlistentry>
        <varlistentry><term xml:id="ping-int"><option>ping-int <replaceable>interval</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>ping-int</secondary>
	</indexterm> When the TCP/IP connection to a peer is idle for more than
	<option>ping-int</option> seconds, DRBD will send a keep-alive packet
	to make sure that a failed peer or network connection is detected
	reasonably soon.  The default value is 10 seconds, with a minimum of 1
	and a maximum of 120 seconds. The unit is seconds.</para></listitem></varlistentry>
        <varlistentry><term xml:id="ping-timeout"><option>ping-timeout <replaceable>timeout</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>ping-timeout</secondary>
	</indexterm> Define the timeout for replies to keep-alive packets.  If
	the peer does not reply within <option>ping-timeout</option>, DRBD will
	close and try to reestablish the connection.  The default value is 0.5
	seconds, with a minimum of 0.1 seconds and a maximum of 3 seconds.  The
	unit is tenths of a second.</para></listitem></varlistentry>
        <varlistentry><term xml:id="socket-check-timeout"><option>socket-check-timeout <replaceable>timeout</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>socket-check-timeout</secondary>
	</indexterm>In setups involving a DRBD-proxy and connections that experience a lot of
        buffer-bloat it might be necessary to set <option>ping-timeout</option> to an
        unusual high value. By default DRBD uses the same value to wait if a newly
        established TCP-connection is stable. Since the DRBD-proxy is usually located
        in the same data center such a long wait time may hinder DRBD's connect process.</para><para>In such setups <option>socket-check-timeout</option> should be set to
	at least to the round trip time between DRBD and DRBD-proxy. I.e. in most
	cases to 1.</para><para>The default unit is tenths of a second, the default value is 0 (which causes
        DRBD to use the value of <option>ping-timeout</option> instead).
	Introduced in 8.4.5.</para></listitem></varlistentry>
        <varlistentry><term xml:id="protocol"><option>protocol <replaceable>name</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>protocol</secondary>
      </indexterm><para>Use the specified protocol on this connection.  The supported
      protocols are:
        <variablelist>
	  <varlistentry>
	    <term xml:id="A"><option>A</option></term>

	    <listitem>
	      <para>Writes to the DRBD device complete as soon as they have
	      reached the local disk and the TCP/IP send buffer.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term xml:id="B"><option>B</option></term>

	    <listitem>
	      <para>Writes to the DRBD device complete as soon as they have
	      reached the local disk, and all peers have acknowledged the
	      receipt of the write requests.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term xml:id="C"><option>C</option></term>

	    <listitem>
	      <para>Writes to the DRBD device complete as soon as they have
	      reached the local and all remote disks.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para></listitem></varlistentry>
        <varlistentry><term xml:id="rcvbuf-size"><option>rcvbuf-size <replaceable>size</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>rcvbuf-size</secondary>
	</indexterm> Configure the size of the TCP/IP receive buffer.  A value
	of 0 (the default) causes the buffer size to adjust dynamically.
	This parameter usually does not need to be set, but it can be set
	to a value up to 10 MiB.  The default unit is bytes.</para></listitem></varlistentry>
        <varlistentry><term xml:id="rr-conflict"><option>rr-conflict</option> <replaceable>policy</replaceable></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>rr-conflict</secondary>
      </indexterm><para>This option helps to solve the cases when the outcome of the resync decision is
      incompatible with the current role assignment in the cluster.  The
      defined policies are:</para><variablelist>
	<varlistentry>
	  <term xml:id="disconnect"><option>disconnect</option></term>

	  <listitem>
	    <para>No automatic resynchronization, simply disconnect.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="violently"><option>violently</option></term>

	  <listitem>
	    <para>Resync to the primary node is allowed, violating the assumption that data on
	    a block device are stable for one of the nodes. <emphasis>Do not
	    use this option, it is dangerous.</emphasis></para> <!-- What would happen? -->
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term xml:id="call-pri-lost"><option>call-pri-lost</option></term>

	  <listitem>
	    <para>Call the <option>pri-lost</option> handler on one of the machines. The handler is
	      expected to reboot the machine, which puts it into secondary role.</para>
	  </listitem>
	</varlistentry>
      </variablelist></listitem></varlistentry>
        <varlistentry><term xml:id="shared-secret"><option>shared-secret <replaceable>secret</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>shared-secret</secondary>
	</indexterm> Configure the shared secret used for peer authentication.
	The secret is a string of up to 64 characters. Peer authentication also
	requires the <option>cram-hmac-alg</option> parameter to be set.</para></listitem></varlistentry>
        <varlistentry><term xml:id="sndbuf-size"><option>sndbuf-size <replaceable>size</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>sndbuf-size</secondary>
	</indexterm> Configure the size of the TCP/IP send buffer.  Since DRBD
      8.0.13 / 8.2.7, a value of 0 (the default) causes the buffer size to
      adjust dynamically.  Values below 32 KiB are harmful to the throughput
      on this connection.  Large buffer sizes can be useful especially when
      protocol A is used over high-latency networks; the maximum value
      supported is 10 MiB.</para></listitem></varlistentry>
        <varlistentry><term xml:id="tcp-cork"><option>tcp-cork</option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>tcp-cork</secondary>
      </indexterm><para>By default, DRBD uses the TCP_CORK socket option to prevent the
      kernel from sending partial messages; this results in fewer and bigger
      packets on the network.  Some network stacks can perform worse with this
      optimization.  On these, the <option>tcp-cork</option> parameter can be
      used to turn this optimization off.</para></listitem></varlistentry>
        <varlistentry><term xml:id="timeout"><option>timeout <replaceable>time</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>timeout</secondary>
	</indexterm> Define the timeout for replies over the network: if a peer
      node does not send an expected reply within the specified <option>timeout</option>,
      it is considered dead and the TCP/IP connection is closed.  The timeout
      value must be lower than <option>connect-int</option> and lower than
      <option>ping-int</option>.  The default is 6 seconds; the value is
      specified in tenths of a second.</para></listitem></varlistentry>
        <varlistentry><term xml:id="unplug-watermark"><option>unplug-watermark <replaceable>number</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>unplug-watermark</secondary>
      </indexterm><para>Mainline kernels before version 2.6.39-rc1 use an explicit
      plug / unplug mechanism to control when a block device starts processing
      queued requests.  On those kernels, the <option>unplug-watermark</option>
      parameter defines how many requests must be queued until a secondary
      node starts processing them.  Some storage controllers perform best when
      <option>unplug-watermark</option> is set to the same value as
      <option>max-buffers</option>; others are more efficient with smaller
      values. The default value for <option>unplug-watermark</option> is 128,
      with a minimum of 16 and a maximum of 131072.</para><para>More recent kernels handle plugging and unplugging implicitly; on
      those kernels, this parameter has no effect. Note that some distributions
      have backported this feature to older kernel versions.</para></listitem></varlistentry>
        <varlistentry><term xml:id="use-rle"><option>use-rle</option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>use-rle</secondary>
	</indexterm> Each replicated device on a cluster node has a separate
	bitmap for each of its peer devices.  The bitmaps are used for tracking
	the differences between the local and peer device: depending on the
	cluster state, a disk range can be marked as different from the peer in
	the device's bitmap, in the peer device's bitmap, or in both bitmaps.
	When two cluster nodes connect, they exchange each other's bitmaps, and
	they each compute the union of the local and peer bitmap to determine
	the overall differences.</para><para>Bitmaps of very large devices are also relatively large, but they
	usually compress very well using run-length encoding.  This can save
	time and bandwidth for the bitmap transfers.</para><para>The <option>use-rle</option> parameter determines if run-length
	encoding should be used.  It is on by default since DRBD 8.4.0.</para></listitem></varlistentry>
        <varlistentry><term xml:id="verify-alg"><option>verify-alg <replaceable>hash-algorithm</replaceable></option></term><listitem><para>Online verification (<command moreinfo="none">drbdadm
	  verify</command>) computes and compares checksums of disk blocks
	(i.e., hash values) in order to detect if they differ.  The
	<option>verify-alg</option> parameter determines which algorithm to use
	for these checksums. It must be set to one of the secure hash algorithms
	supported by the kernel before online verify can be used; see the shash
	algorithms listed in /proc/crypto.</para><para>We recommend to schedule online verifications regularly during
	low-load periods, for example once a month.  Also see the notes on data
	integrity below.</para></listitem></varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>on</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>address
              <replaceable><optional>address-family</optional></replaceable>
              <replaceable>address</replaceable>:<replaceable>port</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>address</secondary>
              </indexterm> Defines the address family, address, and port of a
              connection endpoint.</para>

	    <para>The address families <option>ipv4</option>,
	      <option>ipv6</option>, <option>ssocks</option> (Dolphin
	      Interconnect Solutions' "super sockets"), <option>sdp</option>
	      (Infiniband Sockets Direct Protocol), and <option>sci</option>
	      are supported (<option>sci</option> is an alias for
	      <option>ssocks</option>).  If no address family is specified,
	      <option>ipv4</option> is assumed.  For all address families
	      except <option>ipv6</option>, the address is specified in IPV4
	      address notation (for example, 1.2.3.4).  For
	      <option>ipv6</option>, the address is enclosed in brackets and
	      uses IPv6 address notation (for example, <literal moreinfo="none">[fd01:2345:6789:abcd::1]</literal>).  The port
	      is always specified as a decimal number from 1 to 65535.</para>

            <para>On each host, the port numbers must be unique for each
              address; ports cannot be shared.</para>
          <!-- FIXME: The port should be made optional to avoid duplicate
                      information here and in the connection sections. -->
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>node-id <replaceable>value</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>node-id</secondary>
              </indexterm>
              Defines the unique node identifier for a node in the cluster.
              Node identifiers are used to identify individual nodes in the
              network protocol, and to assign bitmap slots to nodes in the
              metadata.</para>

            <para>Node identifiers can only be reasssigned in a cluster when
              the cluster is down.  It is essential that the node identifiers
              in the configuration and in the device metadata are changed
              consistently on all hosts.  To change the metadata, dump the
              current state with <command moreinfo="none">drbdmeta dump-md</command>, adjust the bitmap slot
              assignment, and update the metadata with
              <command moreinfo="none">drbdmeta restore-md</command>.</para>

            <para>The <option>node-id</option> parameter exists since DRBD 9.
              Its value ranges from 0 to 16; there is no default.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>options</option> Parameters (Resource Options)</title>

      <variablelist>
        <varlistentry><term xml:id="auto-promote"><option>auto-promote <replaceable>bool-value</replaceable></option></term><listitem><indexterm significance="normal">
	<primary>drbd.conf</primary>

	<secondary>auto-promote</secondary>
      </indexterm><para>A resource must be promoted to primary role before any of its devices
      can be mounted or opened for writing.</para><para>Before DRBD 9, this could only be done explicitly ("drbdadm
      primary").  Since DRBD 9, the <option>auto-promote</option> parameter
      allows to automatically promote a resource to primary role when one of
      its devices is mounted or opened for writing.  As soon as all devices are
      unmounted or closed with no more remaining users, the role of the
      resource changes back to secondary.</para><para>Automatic promotion only succeeds if the cluster state allows it
      (that is, if an explicit <command moreinfo="none">drbdadm
	primary</command> command would succeed).  Otherwise, mounting or
      opening the device fails as it already did before DRBD 9: the
      <citerefentry><refentrytitle>mount</refentrytitle><manvolnum>2</manvolnum></citerefentry>
      system call fails with errno set to EROFS (Read-only file system); the
      <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></citerefentry>
      system call fails with errno set to EMEDIUMTYPE (wrong medium
      type).</para><para>Irrespective of the <option>auto-promote</option> parameter, if a
      device is promoted explicitly (<command moreinfo="none">drbdadm
	primary</command>), it also needs to be demoted explicitly (<command moreinfo="none">drbdadm secondary</command>).</para><para>The <option>auto-promote</option> parameter is available since DRBD
      9.0.0, and defaults to <constant>yes</constant>.</para></listitem></varlistentry>
        <varlistentry><term xml:id="cpu-mask"><option>cpu-mask <replaceable>cpu-mask</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>cpu-mask</secondary>
	</indexterm> Set the cpu affinity mask for DRBD kernel threads.  The
	cpu mask is specified as a hexadecimal number.  The default value is 0,
	which lets the scheduler decide which kernel threads run on which CPUs.
	CPU numbers in <option>cpu-mask</option> which do not exist in the
	system are ignored.</para></listitem></varlistentry>
        <varlistentry><term xml:id="on-no-data-accessible"><option>on-no-data-accessible
	<replaceable>policy</replaceable></option></term><listitem><para>Determine how to deal with I/O requests when the requested data is
	not available locally or remotely (for example, when all disks have
	failed).  The defined policies are:

	<variablelist>
	  <varlistentry>
	    <term xml:id="io-error"><option>io-error</option></term>
	    <listitem><para>
		System calls fail with errno set to EIO.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term xml:id="suspend-io"><option>suspend-io</option></term>
	    <listitem><para>
		The resource suspends I/O.  I/O can be resumed by (re)attaching
		the lower-level device, by connecting to a peer which has
		access to the data, or by forcing DRBD to resume I/O with
		<command moreinfo="none">drbdadm resume-io
		  <replaceable>res</replaceable></command>.  When no data is
		available, forcing I/O to resume will result in the same
		behavior as the <option>io-error</option> policy.
	    </para></listitem>
	  </varlistentry>
	</variablelist>

      This setting is available since DRBD 8.3.9; the default policy is
	<option>io-error</option>. </para></listitem></varlistentry>
        <varlistentry><term xml:id="peer-ack-window"><option>peer-ack-window <replaceable>value</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>peer-ack-window</secondary>
	</indexterm>
	On each node and for each device, DRBD maintains a bitmap of the
	differences between the local and remote data for each peer device.
	For example, in a three-node setup (nodes A, B, C) each with a single
	device, every node maintains one bitmap for each of its peers.</para><para>When nodes receive write requests, they know how to update the
	bitmaps for the writing node, but not how to update the bitmaps between
	themselves.  In this example, when a write request propagates from node
	A to B and C, nodes B and C know that they have the same data as node
	A, but not whether or not they both have the same data.</para><para>As a remedy, the writing node occasionally sends peer-ack packets
	to its peers which tell them which state they are in relative to each
	other.</para><para>The <option>peer-ack-window</option> parameter specifies how much
	data a primary node may send before sending a peer-ack packet.  A low
	value causes increased network traffic; a high value causes less
	network traffic but higher memory consumption on secondary nodes and
	higher resync times between the secondary nodes after primary node
	failures. (Note: peer-ack packets may be sent due to other reasons as
        well, e.g. membership changes or expiry of the
        <option>peer-ack-delay</option> timer.)</para><para>The default value for <option>peer-ack-window</option> is 2 MiB,
	the default unit is sectors.  This option is available since
	9.0.0.</para></listitem></varlistentry>
        <varlistentry><term xml:id="peer-ack-delay"><option>peer-ack-delay <replaceable>expiry-time</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>peer-ack-delay</secondary>
	</indexterm>
	If after the last finished write request no new write request gets issued for
	<replaceable>expiry-time</replaceable>, then a peer-ack packet is sent.
	If a new write request is issued before the timer expires, the timer gets reset
	to <replaceable>expiry-time</replaceable>. (Note: peer-ack packets may be sent
        due to other reasons as well, e.g. membership changes or the
        <option>peer-ack-window</option> option.)</para><para>This parameter may influence resync behavior on remote nodes. Peer nodes
	need to wait until they receive an peer-ack for releasing a lock on an AL-extent.
	Resync operations between peers may need to wait for for these locks.
	</para><para>The default value for <option>peer-ack-delay</option> is 100 milliseconds,
	the default unit is milliseconds.  This option is available since
	9.0.0.</para></listitem></varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>startup</option> Parameters</title>

      <para>The parameters in this section define the behavior of DRBD at
        system startup time, in the DRBD init script.  They have no effect once
        the system is up and running.</para>

      <variablelist>
	<varlistentry><term xml:id="degr-wfc-timeout"><option>degr-wfc-timeout <replaceable>timeout</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>degr-wfc-timeout</secondary>
	</indexterm> Define how long to wait until all peers are
	connected in case the cluster consisted of a single node only
	when the system went down.  This parameter is usually set to a
	value smaller than <option>wfc-timeout</option>.  The
	assumption here is that peers which were unreachable before a
	reboot are less likely to be be reachable after the reboot, so
	waiting is less likely to help.</para><para>The timeout is specified in seconds. The default value is 0,
	which stands for an infinite timeout.  Also see the
	<option>wfc-timeout</option> parameter.</para></listitem></varlistentry>
	<varlistentry><term xml:id="outdated-wfc-timeout"><option>outdated-wfc-timeout <replaceable>timeout</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>outdated-wfc-timeout</secondary>
	</indexterm> Define how long to wait until all peers are
	connected if all peers were outdated when the system went down.
	This parameter is usually set to a value smaller than
	<option>wfc-timeout</option>.  The assumption here is that an
	outdated peer cannot have become primary in the meantime, so we
	don't need to wait for it as long as for a node which was alive
	before.</para><para>The timeout is specified in seconds. The default value is 0,
	which stands for an infinite timeout.  Also see the
	<option>wfc-timeout</option> parameter.</para></listitem></varlistentry>

        <varlistentry>
          <term><option>stacked-timeouts</option></term>

          <listitem>
            <para>On stacked devices, the <option>wfc-timeout</option> and
              <option>degr-wfc-timeout</option> parameters in the configuration
              are usually ignored, and both timeouts are set to twice the
              <option>connect-int</option> timeout.  The
              <option>stacked-timeouts</option> parameter tells DRBD to use the
              <option>wfc-timeout</option> and
              <option>degr-wfc-timeout</option> parameters as defined in the
              configuration, even on stacked devices.  Only use this parameter
              if the peer of the stacked resource is usually not available, or
              will not become primary.  Incorrect use of this parameter can
              lead to unexpected split-brain scenarios.</para>
          </listitem>
        </varlistentry>

	<varlistentry><term xml:id="wait-after-sb"><option>wait-after-sb</option></term><listitem><para>This parameter causes DRBD to continue waiting in the init
	script even when a split-brain situation has been detected, and
	the nodes therefore refuse to connect to each other.</para></listitem></varlistentry>
	<varlistentry><term xml:id="wfc-timeout"><option>wfc-timeout <replaceable>timeout</replaceable></option></term><listitem><para><indexterm significance="normal">
	  <primary>drbd.conf</primary>

	  <secondary>wfc-timeout</secondary>
	</indexterm> Define how long the init script waits until all peers are
	connected.  This can be useful in combination with a cluster manager
	which cannot manage DRBD resources: when the cluster manager starts,
	the DRBD resources will already be up and running.  With a more capable
	cluster manager such as Pacemaker, it makes more sense to let the
	cluster manager control DRBD resources.  The timeout is specified in
	seconds. The default value is 0, which stands for an infinite timeout.
	Also see the <option>degr-wfc-timeout</option> parameter.</para></listitem></varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Section <option>volume</option> Parameters</title>

      <variablelist>
        <varlistentry>
          <term><option>device /dev/drbd<replaceable>minor-number</replaceable></option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>device</secondary>
              </indexterm> Define the device name and minor number of a
              replicated block device.  This is the device that applications
              are supposed to access; in most cases, the device is not used
              directly, but as a file system. This parameter is required and
              the standard device naming convention is assumed.</para>

            <para>In addition to this device, udev will create
              <option>/dev/drbd/by-res/<replaceable>resource</replaceable>/<replaceable>volume</replaceable></option>
              and <option>/dev/drbd/by-disk/<replaceable>lower-level-device</replaceable></option>
              symlinks to the device.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
	  <term><option>disk</option>
	      <group choice="req" rep="norepeat">
		<arg rep="norepeat" choice="opt">disk</arg>
		<arg choice="plain" rep="norepeat"><option>none</option></arg>
	      </group>
	    </term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>disk</secondary>
              </indexterm> Define the lower-level block device that DRBD will
              use for storing the actual data.  While the replicated drbd
              device is configured, the lower-level device must not be used directly.
              Even read-only access with tools like <citerefentry>
                <refentrytitle>dumpe2fs</refentrytitle>
                <manvolnum>8</manvolnum> </citerefentry> and similar is not
	      allowed. The keyword <option>none</option> specifies that no
	      lower-level block device is configured; this also overrides
	      inheritance of the lower-level device.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>meta-disk internal</option></term>

          <term><option>meta-disk <replaceable>device</replaceable></option></term>

          <term><option>meta-disk <replaceable>device</replaceable> [<replaceable>index</replaceable>]</option></term>

          <listitem>
            <para><indexterm significance="normal">
                <primary>drbd.conf</primary>

                <secondary>meta-disk</secondary>
              </indexterm> Define where the metadata of a replicated block
              device resides: it can be <option>internal</option>, meaning that the lower-level
              device contains both the data and the metadata, or on a separate
              device.</para>

            <para>When the <replaceable>index</replaceable> form of this
              parameter is used, multiple replicated devices can share the same
              metadata device, each using a separate index.  Each index
              occupies 128 MiB of data, which corresponds to a replicated
	      device size of at most 4 TiB with two cluster nodes.  We
	      recommend not to share metadata devices anymore, and to instead
	      use the lvm volume manager for creating metadata devices as
	      needed.</para>

            <para>When the <replaceable>index</replaceable> form of this
              parameter is not used, the size of the lower-level device
              determines the size of the metadata.  The size needed is 36 KiB +
              (size of lower-level device) / 32K * (number of nodes - 1).  If <!-- FIXME: al-striping, al-extents 65536? -->
              the metadata device is bigger than that, the extra space is not
              used.</para>
	    <para>This parameter is required if a <option>disk</option> other
	      than <option>none</option> is specified, and ignored if
	      <option>disk</option> is set to <option>none</option>.  A
	      <option>meta-disk</option> parameter without a
	      <option>disk</option> parameter is not allowed.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>
  </refsect1>

  <refsect1 id="data-integrity">
    <title>Notes on data integrity</title>

    <para>DRBD supports two different mechanisms for data integrity checking:
      first, the <option>data-integrity-alg</option> network parameter allows
      to add a checksum to the data sent over the network.  Second, the online
      verification mechanism (<command moreinfo="none">drbdadm verify</command>
      and the <option>verify-alg</option> parameter) allows to check for
      differences in the on-disk data.</para>

    <para>Both mechanisms can produce false positives if the data is modified
      during I/O (i.e., while it is being sent over the network or written to
      disk).  This does not always indicate a problem: for example, some
      file systems and applications do modify data under I/O for certain
      operations.  Swap space can also undergo changes while under I/O.</para>

    <para>Network data integrity checking tries to identify data modification
      during I/O by verifying the checksums on the sender side after sending the
      data.  If it detects a mismatch, it logs an error.  The receiver also
      logs an error when it detects a mismatch.  Thus, an error logged only on
      the receiver side indicates an error on the network, and an error logged
      on both sides indicates data modification under I/O.</para>

    <para>The most recent example of systematic data corruption was identified
      as a bug in the TCP offloading engine and driver of a certain type of
      GBit NIC in 2007: the data corruption happened on the DMA transfer from
      core memory to the card. Because the TCP checksum were calculated on the
      card, the TCP/IP protocol checksums did not reveal this problem.</para>
  </refsect1>

  <refsect1>
    <title>Version</title>

    <simpara>This document was revised for version 9.0.0 of the DRBD distribution.</simpara>
  </refsect1>

  <refsect1>
    <title>Author</title>

    <simpara>Written by Philipp Reisner <email>philipp.reisner@linbit.com</email> and Lars
    Ellenberg <email>lars.ellenberg@linbit.com</email>.</simpara>
  </refsect1>

  <refsect1>
    <title>Reporting Bugs</title>

    <simpara>Report bugs to <email>drbd-user@lists.linbit.com</email>.</simpara>
  </refsect1>

  <refsect1>
    <title>Copyright</title>

    <simpara>Copyright 2001-2012 LINBIT Information Technologies, Philipp Reisner, Lars Ellenberg.
    This is free software; see the source for copying conditions. There is NO warranty; not even
    for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</simpara>
  </refsect1>

  <refsect1>
    <title>See Also</title>

    <para><citerefentry>
        <refentrytitle>drbd</refentrytitle>

        <manvolnum>8</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>drbddisk</refentrytitle>

        <manvolnum>8</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>drbdsetup</refentrytitle>

        <manvolnum>8</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>drbdadm</refentrytitle>

        <manvolnum>8</manvolnum>
      </citerefentry>,
      <ulink url="http://www.drbd.org/users-guide/"><citetitle>DRBD User's Guide</citetitle></ulink>,
       <ulink url="http://www.drbd.org/"><citetitle>DRBD Web Site</citetitle></ulink></para>

  </refsect1>
</refentry>
